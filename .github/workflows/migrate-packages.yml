# The workflow migrates Maven packages between two GitHub Organizations
# This workflow will be trigged by a label added to an issue named 'start-migration'

name: Migrate Maven Packages
on:
    issues:
        types: [labeled]

jobs:
    migrate-packages:
        if: github.event.label.name == 'start-migration'
        runs-on: ubuntu-latest
        outputs:
          cache-key: ${{ steps.extract-params.outputs.cache-key }}
          to-org: ${{ steps.extract-params.outputs.to-org }}
          from-org: ${{ steps.extract-params.outputs.from-org }}
          package-list: ${{ steps.filter-packages.outputs.filtered-packages }}

        steps:        
          - name: Extract parameters from issue body
            id: extract-params
            run: |
                FROM_ORG=$(echo '${{ github.event.issue.body }}' | awk '/### Source Organization Name/{getline; getline; print; exit}')
                TO_ORG=$(echo '${{ github.event.issue.body }}' | awk '/### Destination Organization Name/{getline; getline; print; exit}')
                PACKAGE_LIST=$(echo '${{ github.event.issue.body }}' | awk '/<!-- package-list="/{print; exit}' | sed 's/<!-- //;s/ -->//')
                CACHE_KEY=$(echo '${{ github.event.issue.body }}' | awk '/<!-- cache-key="/{print; exit}' | sed 's/<!-- //;s/ -->//' | tr -d '"')
                TASKS=$(echo '${{ github.event.issue.body }}' | awk '/### Package List/,/> **Note**/' | grep '\[x\]' | sed -n 's/.*\] \(.*\) (\(.*\))/\1/p' | jq -R -s -c 'split("\n")[:-1]')
                echo "from-org=$FROM_ORG" >> "$GITHUB_OUTPUT"
                echo "to-org=$TO_ORG" >> "$GITHUB_OUTPUT"
                echo "$CACHE_KEY" >> "$GITHUB_OUTPUT"
                echo "selected-tasks=$TASKS" >> "$GITHUB_OUTPUT"
                echo "$PACKAGE_LIST" >> "$GITHUB_OUTPUT"
                # echo "from-org=$FROM_ORG" >> "$GITHUB_STEP_SUMMARY"
                # echo "to-org=$TO_ORG" >> "$GITHUB_STEP_SUMMARY"
                # echo "$CACHE_KEY" >> "$GITHUB_STEP_SUMMARY"
                # echo "selected-tasks=$TASKS" >> "$GITHUB_STEP_SUMMARY"
                # echo "$PACKAGE_LIST" >> "$GITHUB_STEP_SUMMARY"
            shell: bash

          - name: Find selected packages
            id: filter-packages
            run: |
              FILTERED_PACKAGES=$(echo '${{ fromJson(steps.extract-params.outputs.package-list) }}' | jq -c --argjson tasks '${{ steps.extract-params.outputs.selected-tasks }}' '[.[] | select(.name as $name | $tasks | index($name))]')
              echo "filtered-packages=$FILTERED_PACKAGES" >> "$GITHUB_OUTPUT"
              # echo "filtered-packages=$FILTERED_PACKAGES" >> "$GITHUB_STEP_SUMMARY"
            shell: bash
  
    upload-assets:
      needs: migrate-packages
      runs-on: ubuntu-latest

      strategy:
        max-parallel: 1
        matrix:
          pkg: ${{fromJson(needs.migrate-packages.outputs.package-list)}}

      outputs:
        run-id: ${{ github.run_id }}

      steps:
        - name: Check out code
          uses: actions/checkout@v4

        # retrieve cache
        - name: Restore JSON files from cache
          uses: actions/cache@v4.0.1
          with:
            key: |
              ${{ needs.migrate-packages.outputs.cache-key }}
            path: |
              *.json
            fail-on-cache-miss: true
              
        - name: Upload ${{ matrix.pkg.name }} to ${{ needs.migrate-packages.outputs.to-org }}
          uses: ./.github/actions/upload-maven-package-from-json
          with:
            package-import-json-file: ${{ matrix.pkg.file }}
            from-org-pat: ${{ secrets.FROM_ORG_PAT }}
            to-org: ${{ needs.migrate-packages.outputs.to-org }}
            to-org-pat: ${{ secrets.TO_ORG_PAT }}
        
    report-status:
      if: always()
      needs: upload-assets
      runs-on: ubuntu-latest
      permissions:
        actions: read
        issues: write

      steps:
        - name: Check out code
          uses: actions/checkout@v4
        
        - name: Report status
          run: |
            echo "run id of previous job: ${{ needs.upload-assets.outputs.run-id }}"
          shell: bash

        - name: Get job logs
          run: |
            RUN_ID=${{ github.run_id }}
            OWNER_REPO=${{ github.repository }}
            JOB_NAME="upload-assets"
            
            # List all jobs for this workflow run
            JOBS_JSON=$(gh api repos/$OWNER_REPO/actions/runs/$RUN_ID/jobs)

            # echo "Jobs JSON: $JOBS_JSON" >> $GITHUB_STEP_SUMMARY
            
            # Find the job ID for the job with the name that starts with "upload-assets" and create a json array of the job IDs
            JOB_ID=$(echo $JOBS_JSON | jq '[.jobs[] | select(.name | startswith("upload-assets")) | {id: .id, name: .name, workflow_name: .workflow_name, status: .status, conclusion: .conclusion, started_at: .started_at, completed_at: .completed_at}]')

            echo "Job IDs: $JOB_ID" >> $GITHUB_STEP_SUMMARY
            
            # Loop through items in the JSON array, and for each item get the id, name, workflow_name, status, conclusion, started_at, completed_at
            # use the id to get the logs for the job
            for row in $(echo "${JOB_ID}" | jq -r '.[] | @base64'); do
              _jq() {
                echo ${row} | base64 --decode | jq -r ${1}
              }
              JOB_ID=$(_jq '.id')
              JOB_NAME=$(echo $(_jq '.name') | cut -d ' ' -f 2)
              JOB_LOGS=$(gh api repos/$OWNER_REPO/actions/jobs/$JOB_ID/logs)
              JOB_STATUS=$(_jq '.status')
              JOB_CONCLUSION=$(_jq '.conclusion')
              JOB_STARTED_AT=$(_jq '.started_at')
              JOB_COMPLETED_AT=$(_jq '.completed_at')

              # Convert JOB_LOGS to a markdown table with two columns with no header row
              # each line of the logs is a row in the table
              # the first column if the first word of the line
              # the second column is the rest of the line
              JOB_LOGS=$(echo "$JOB_LOGS" | jq -r '.[] | @base64' | while read row; do
                _jq() {
                  echo ${row} | base64 --decode | jq -r ${1}
                }
                echo "* $(_jq '.line')"
              done)
              
              # Use the gh cli to post a comment to the issue with the logs
              gh issue comment ${{ github.event.issue.number }} -b "<details><summary>$JOB_NAME ($JOB_STATUS/$JOB_CONCLUSION): $JOB_STARTED_AT - $JOB_COMPLETED_AT</summary>|---|---|\n$JOB_LOGS|---|---|\n</details>"
            done
          shell: bash
          env:
            GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}